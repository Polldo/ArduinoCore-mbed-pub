from __future__ import print_function
import os
import shutil
import re
import json
import sys
import subprocess

import glob

class CoreWrapper:

  def __init__(self, mbed_path):
    self.mbed_path = mbed_path


  def configure(self, arduino_variant, arduino_core_mbed, board_name, profile):
    self.arduino_variant = arduino_variant
    self.arduino_core_mbed = arduino_core_mbed
    self.board_name = board_name
    self.profile = profile
    self.gcc_path = self.mbed_path + "/BUILD/" + self.board_name + "/GCC_ARM" + self.profile


  def generate_defines (self):
    print("Generating defines...")
    # Open macros generated by mbed-os compilation
    macros_path = os.path.join(self.mbed_path, self.board_name + ".macros.txt")
    with open(macros_path, "r") as macros_file:
      macros = macros_file.read()
      # Add an escape char to all double quotes in the macros
      macros = macros.replace("\"", "\\" + "\"")
      # Handle macros in a list
      macros_list = macros.split()
      # Remove the "Macros" label
      macros_list.remove("Macros:")
      macros_list.append("-DMBED_NO_GLOBAL_USING_DIRECTIVE=1")
      if os.path.isfile(self.arduino_variant + "/variant.cpp"):
        macros_list.append("-DUSE_ARDUINO_PINOUT")
      macros_list.sort()
      # Save the macros into the arduino core variant
      with open(self.arduino_variant + "/defines.txt", "w") as output_file:
        for macro in macros_list:
          output_file.write("%s\n" % macro)
    print(" done.")


  def generate_includes (self):
    print("Generating includes...")
    # Clean old includes file if any
    output_path = self.arduino_variant + "/includes.txt"
    with open(output_path, "w") as outfile:
      pass

    # Search and open includes files generated by mbed-os compilation
    #includes_path = self.mbed_path + "/BUILD/" + self.board_name + "/GCC_ARM" + self.profile
    includes_path = self.gcc_path
    for filename in os.listdir(includes_path):
      if ".include" in filename:
        with open(os.path.join(includes_path, filename), "r") as includes_file:
          includes = includes_file.read().split()

          # Open in append mode, in case there are more '.includes' files
          with open(output_path, "a") as outfile:
            for include_line in reversed(includes):
              include_line = include_line.replace(" ", "\n")
              include_line = include_line.replace("\"", "")
              include_line = include_line.replace("-I./mbed-os", "-iwithprefixbefore/mbed")
              if not re.match("^-I", include_line):
                outfile.write("%s\n" % include_line)

    print(" copying to destination... ")
    with open(output_path, "r") as infile:
      for line in infile.read().split("\n"):
        if "targets" in line:
          line = str(re.sub("^.*mbed/", "", line))
          #print()
          #print(line)
          mbed_os_path = os.path.join(self.mbed_path, "mbed-os", line)
          for filename in os.listdir(mbed_os_path):
            if ".h" in filename:
              source_path = os.path.join(mbed_os_path, filename)
              #dest_path = os.path.join(self.arduino_core_mbed, filename)
              dest_path = os.path.join(self.arduino_core_mbed, line, filename)
              #print(source_path)
              #print(dest_path)
              os.makedirs(os.path.dirname(dest_path), exist_ok=True)
              shutil.copy2(source_path, dest_path)
    print(" done.")


  # return True if the flag should be added to the flags file
  def filter_flag(self, flag, suffix):
    if "-MMD" in flag:
      return False

    #TODO: test this by compiling for portenta
    if "PORTENTA" in self.arduino_variant and "-fno-exceptions" in flag:
      print("Patching '-fno-exceptions' flag for " + self.arduino_variant + "/" + suffix + "flags.txt")
    return True

  def generate_flags (self):
    print("Generating flags...")
    input_suffixes = ["c", "cxx", "ld"]
    for suffix in input_suffixes:
      input_path = os.path.join(self.gcc_path, ".profile-" + suffix)
      with open(input_path) as json_file:
        data = json.load(json_file)

        # Filter flags and save them in the variant
        output_path = os.path.join(self.arduino_variant, (suffix + "flags.txt"))
        with open(output_path, "w") as outfile:
          for flag in data["flags"]:
            if self.filter_flag(flag, suffix):
              outfile.write("%s\n" % flag)
    print(" done.")


  def __execute_cmd(self, cmd, args):
    process = subprocess.Popen(cmd.split() + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
    log, error = process.communicate()
    #log, error = process.communicate(args)
    if error:
      print("Error while executing command:  " + cmd)
      print(error)
      sys.exit()
    else:
      print(log, end='')

  def generate_libs (self):
    print("Generating libs...")
    # Extract object files 
    link_opt_path = self.gcc_path + "/.link_options.txt"
    with open(link_opt_path, "r") as infile:
      link_objs = infile.read().split()
      filtered_objs = [obj for obj in link_objs if ".o" in obj and not "main.o" in obj]
      cmd = "arm-none-eabi-ar rcs " + self.mbed_path + "/BUILD/mbed-core-" + self.board_name + ".a"
      #print(link_objs)
      #print(cmd)
      self.__execute_cmd(cmd, filtered_objs)

      shutil.copy2(self.mbed_path + "/BUILD/mbed-core-" + self.board_name + ".a", 
                  self.arduino_variant + "/libs/libmbed.a") 
      shutil.copy2(self.gcc_path + "/.link_script.ld", self.arduino_variant + "/linker_script.ld")
      shutil.copy2(self.gcc_path + "/mbed_config.h", self.arduino_variant + "/mbed_config.h")
    print(" done.")


  def dir_contains_header(dir):
    for filename in os.listdir(dir):
      if ".h" in filename:
        return True
    return False

  def copy_core_files (self):
    print("Copying generic MbedOS headers to core... ")
    dest = self.arduino_core_mbed + "/*"
    shutil.rmtree(dest, ignore_errors=True)
    # WARNING: python3 only
    included_paths = ["/mbed-os/**/*.h", "/mbed-os/**/mstd_*"]
    excluded_paths = ["targets/", "*TEST*/"]
    for include in included_paths:
      for filename in glob.glob(self.mbed_path + include, recursive=True):
        if any(re.match(exclude_name, filename) for exclude_name in excluded_paths):
          continue
        dest_path = re.sub(".*/mbed-os/", dest, filename)
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        shutil.copy2(filename, dest_path)

    print(" done.")
